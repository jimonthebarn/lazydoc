{"name":"Lazydoc","tagline":"A framework for automatic REST-API documentation","body":"Lazydoc is a modular framework to collect documentation data from your source code and generate artifacts for documentation frameworks like Swagger, DocBook, etc.\r\n\r\n# Getting Started\r\n\r\nTo use lazydoc you have to create a small java class which configures and executes lazydoc. The goal is to replace this with a maven plugin, but at the moment there are problems with class loading. As soon as this is solved this section will be updated.\r\n\r\nLazydoc is currently just supporting a parser for Spring REST, but it will also support JAX-RS and other REST frameworks in the future.\r\n\r\n### Lazydoc configuration class\r\n\r\n      public class ExampleDocParser {\r\n      \r\n          public static void main(String[] args) throws Exception {\r\n              Config config = new Config();\r\n              config.setPackageToSearchForControllers(\"org.lazydoc.example\");\r\n              new LazyDoc(config).document();\r\n          }\r\n      }\r\n\r\nTo get started you just need to set the package where lazydoc should search for controllers. Now just start it with the maven java exec plugin. As main class use the class you created. As argument the project basedir is provided which is used to point the generators to the path they should create the artifacts.\r\n\r\n      <plugin>\r\n          <groupId>org.codehaus.mojo</groupId>\r\n          <artifactId>exec-maven-plugin</artifactId>\r\n          <version>1.1.1</version>\r\n          <executions>\r\n             <execution>\r\n                <phase>compile</phase>\r\n                <goals>\r\n                   <goal>java</goal>\r\n                </goals>\r\n                <configuration>\r\n                    <includeProjectDependencies>true</includeProjectDependencies>\r\n                    <mainClass>org.lazydoc.example.simple.doc.ExampleDocParser</mainClass>\r\n                    <arguments>\r\n                        <argument>${project.basedir}/</argument>\r\n                    </arguments>\r\n                </configuration>\r\n             </execution>\r\n          </executions>\r\n      </plugin>\r\n  \r\n### Documenting an controller\r\n\r\nLazydoc is using an annotation based approache to add the additional information which is needed to generate the documentation artifacts. The following example shows the usage of the annotations. See detailed description of the annotations below.\r\n\r\n    @Controller\r\n    @DomainDescription(order = 1, name = \"Customer\", description=\"Operations for customer management\")\r\n    public class RestfulCustomerController {\r\n        ....\r\n        @RequestMapping(value = \"/customers/{customerId}\", method = RequestMethod.GET)\r\n        @OperationDescription(description = \"Returns the customer for the given id\")\r\n        @ParameterDescription({@Parameter(name=\"customerId\", description = \"The id of the customer to be returned\")})\r\n        @ResponseDescription(description = \"The customer requested by id\")\r\n        public @ResponseBody Customer getCustomer(@PathVariable long customerId) {\r\n            ....\r\n        }\r\n    \r\n        @RequestMapping(value = \"/customers\", method = RequestMethod.POST)\r\n        @OperationDescription(description = \"Creates a new customer\")\r\n        @ParameterDescription({@Parameter(name=\"requestBody\", description = \"The data of the customer to be created\")})\r\n        @ResponseDescription(description = \"The newly created customer\")\r\n        public @ResponseBody Customer createCustomer(@RequestBody Customer customer) {\r\n            ....\r\n        }\r\n    \r\n        @RequestMapping(value = \"/customers/{customerId}\", method = RequestMethod.PUT)\r\n        @OperationDescription(description = \"Updates a customer specified by the id\")\r\n        @ParameterDescription({\r\n                @Parameter(name = \"customerId\", description = \"The id of the customer to be updated\"),\r\n                @Parameter(name=\"requestBody\", description = \"The data of the customer to be created\")})\r\n        @ResponseDescription(description = \"The updated customer\")\r\n        public @ResponseBody Customer updateCustomer(@PathVariable long customerId, @RequestBody Customer customer) {\r\n            ....\r\n        }\r\n    \r\n        @ExceptionHandler(CustomerNotFoundException.class)\r\n        @ResponseStatus(value = HttpStatus.NOT_FOUND)\r\n        @ErrorDescription(description = \"This error occurs if the customer was not found\")\r\n        public @ResponseBody\r\n        String handleException(Exception ex) {\r\n            return \"The customer was not found\";\r\n        }\r\n    \r\n    }\r\n\r\nIn this example the annotations for documentation are put directly in the controller class. But this litters the class too much. Lazydoc offers the possibility to put the documentation annotations in a different class. Currently there is just a strategy to configure a suffix for the controller class to lookup the documentation class. So for example if your controller is **RestfulCustomerController** and your suffix is **Documentation**, lazydoc will look for a (abstract) class or interface with the name **RestfulCustomerControllerDocumentation** in the same package. The package with the documentation class can be in a different project as long as it is accessible in the compile phase.\r\n\r\n# Configuration\r\n\r\n*** will be updated in the next few days ***\r\n\r\n#### Config\r\n* packageToSearchForControllers\r\n* breakOnUndocumented\r\n* documentationSuffix\r\n* dataTypeSuffix\r\n* baseDTOClassname\r\n* customAnnotationToBeIgnored\r\n* exceptionHandlerInvoker\r\n* abstractControllerClassForCommonExceptionHandlers\r\n* instanceControllerClassForCommonExceptionHandlers\r\n* stopInspectionAtAbstractController\r\n* controllerClassToStopErrorInspection\r\n\r\n\r\n### PrinterConfig\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}