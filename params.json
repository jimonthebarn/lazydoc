{"name":"Lazydoc","tagline":"A framework for automatic REST-API documentation","body":"Lazydoc is a modular framework to collect documentation data from your source code and generate artifacts for documentation frameworks like Swagger, DocBook, etc.\r\n\r\n# Getting Started\r\n\r\nTo use lazydoc you can integrate the lazydoc maven plugin in your maven pom file or you can create a custom java class which configures and executes lazydoc. The different configuration options are described in the configuration section below.\r\n\r\nLazydoc is currently just supporting a parser for Spring REST, but it will also support JAX-RS and other REST frameworks in the future.\r\n\r\n## Use the lazydoc maven plugin\r\n\r\nLazydoc provides a maven plugin which configures and executes lazydoc. \r\n\r\n### Lazydoc maven plugin example\r\n\r\n            <plugin>\r\n                <groupId>org.lazydoc</groupId>\r\n                <artifactId>lazydoc-plugin</artifactId>\r\n                <version>1.0.0</version>\r\n                <executions>\r\n                    <execution>\r\n                        <goals>\r\n                            <goal>document</goal>\r\n                        </goals>\r\n                        <phase>compile</phase>\r\n                    </execution>\r\n                </executions>\r\n                <configuration>\r\n                    <config>\r\n                        <packageToSearchForControllers>org.lazydoc.example</packageToSearchForControllers>\r\n                        <documentationSuffix>Documentation</documentationSuffix>\r\n                    </config>\r\n                    <printerConfigs>\r\n                        <printerConfig>\r\n                            <className>org.lazydoc.printer.DocBookDocumentationPrinter</className>\r\n                            <outputPath>${project.parent.basedir}/lazydoc-docbookexample/src/docbkx/lazydoc/</outputPath>\r\n                            <params>\r\n                               <docbook.filename>lazydoc.xml</docbook.filename>\r\n                            </params>\r\n                        </printerConfig>\r\n                    </printerConfigs>\r\n                </configuration>\r\n            </plugin>\r\n\r\n## Use a custom java class\r\n\r\nTo use lazydoc you can create a small java class which configures and executes lazydoc. \r\n\r\n### Lazydoc configuration class example\r\n\r\n      public class ExampleDocParser {\r\n      \r\n          public static void main(String[] args) throws Exception {\r\n              Config config = new Config();\r\n              config.setPackageToSearchForControllers(\"org.lazydoc.example\");\r\n              new LazyDoc(config).document();\r\n          }\r\n      }\r\n\r\nTo get started you just need to set the package where lazydoc should search for controllers. Now just start it with the maven java exec plugin. As main class use the class you created. As argument the project basedir is provided which is used to point the generators to the path they should create the artifacts.\r\n\r\n      <plugin>\r\n          <groupId>org.codehaus.mojo</groupId>\r\n          <artifactId>exec-maven-plugin</artifactId>\r\n          <version>1.1.1</version>\r\n          <executions>\r\n             <execution>\r\n                <phase>compile</phase>\r\n                <goals>\r\n                   <goal>java</goal>\r\n                </goals>\r\n                <configuration>\r\n                    <includeProjectDependencies>true</includeProjectDependencies>\r\n                    <mainClass>org.lazydoc.example.simple.doc.ExampleDocParser</mainClass>\r\n                    <arguments>\r\n                        <argument>${project.basedir}/</argument>\r\n                    </arguments>\r\n                </configuration>\r\n             </execution>\r\n          </executions>\r\n      </plugin>\r\n  \r\n### Documenting a controller\r\n\r\nLazydoc is using an annotation based approache to add the additional information which is needed to generate the documentation artifacts. The following example shows the usage of the annotations. See detailed description of the annotations below.\r\n\r\n    @Controller\r\n    @DomainDescription(order = 1, name = \"Customer\", description=\"Operations for customer management\")\r\n    public class RestfulCustomerController {\r\n        ....\r\n        @RequestMapping(value = \"/customers/{customerId}\", method = RequestMethod.GET)\r\n        @OperationDescription(description = \"Returns the customer for the given id\")\r\n        @ParameterDescription({@Parameter(name=\"customerId\", description = \"The id of the customer to be returned\")})\r\n        @ResponseDescription(description = \"The customer requested by id\")\r\n        public @ResponseBody Customer getCustomer(@PathVariable long customerId) {\r\n            ....\r\n        }\r\n    \r\n        @RequestMapping(value = \"/customers\", method = RequestMethod.POST)\r\n        @OperationDescription(description = \"Creates a new customer\")\r\n        @ParameterDescription({@Parameter(name=\"requestBody\", description = \"The data of the customer to be created\")})\r\n        @ResponseDescription(description = \"The newly created customer\")\r\n        public @ResponseBody Customer createCustomer(@RequestBody Customer customer) {\r\n            ....\r\n        }\r\n    \r\n        @RequestMapping(value = \"/customers/{customerId}\", method = RequestMethod.PUT)\r\n        @OperationDescription(description = \"Updates a customer specified by the id\")\r\n        @ParameterDescription({\r\n                @Parameter(name = \"customerId\", description = \"The id of the customer to be updated\"),\r\n                @Parameter(name=\"requestBody\", description = \"The data of the customer to be created\")})\r\n        @ResponseDescription(description = \"The updated customer\")\r\n        public @ResponseBody Customer updateCustomer(@PathVariable long customerId, @RequestBody Customer customer) {\r\n            ....\r\n        }\r\n    \r\n        @ExceptionHandler(CustomerNotFoundException.class)\r\n        @ResponseStatus(value = HttpStatus.NOT_FOUND)\r\n        @ErrorDescription(description = \"This error occurs if the customer was not found\")\r\n        public @ResponseBody\r\n        String handleException(Exception ex) {\r\n            return \"The customer was not found\";\r\n        }\r\n    \r\n    }\r\n\r\nIn this example the annotations for documentation are put directly in the controller class. But this litters the class too much. Lazydoc offers the possibility to put the documentation annotations in a different class. Currently there is just a strategy to configure a suffix for the controller class to lookup the documentation class. So for example if your controller is **RestfulCustomerController** and your suffix is **Documentation**, lazydoc will look for a (abstract) class or interface with the name **RestfulCustomerControllerDocumentation** in the same package. The package with the documentation class can be in a different project as long as it is accessible in the compile phase.\r\n\r\nThe annotation can be included in your project with the following maven dependency\r\n\r\n      <dependency>\r\n           <groupId>org.lazydoc</groupId>\r\n           <artifactId>lazydoc-annotation</artifactId>\r\n           <version>1.0.0</version>\r\n      </dependency>\r\n\r\n# Configuration\r\n\r\nThe configuration of lazydoc is done with a common configuration and a configuration for every printer for what you want to generate documentation for.\r\n\r\n## Config\r\n\r\n#### packageToSearchForControllers\r\n\r\nThe package where lazydoc can find the controllers which should be documented.\r\n\r\n#### breakOnUndocumented\r\n\r\nIf this flag is set to true the build process will fail if there are undocumented artifacts.\r\n\r\n#### documentationSuffix\r\n\r\nLazydoc offers to put the documentation annotation in a different class  in the same package. This can be used to avoid loitering the controller class with documentation annotation. If the documentationSuffix is defined lazydoc will look for the documentation annotations in a class or interface with controller name +  documentation suffix. So for example if the controller is named RestfulCustomerController and the documentation suffix is Documentation lazydoc expects to find a class RestfulCustomerControllerDocumentation\r\n\r\n#### dataTypeSuffix\r\n\r\nIf the controller uses for its data transfer object (DTO) a common suffix like DTO or VO (Value Object) or something else you can tell lazydoc with the dataTypeSuffix to not include the suffix in the documentation. So for example if the DTO class is called CustomerDTO lazydoc will just use the Customer part in the documentation. \r\n\r\n#### baseDTOClassname\r\n\r\nIf the DTO classes all share a common base DTO class lazydoc can check if all classes found are inherited by this base class. The name of the class is configured with baseDTOClassname. This is useful if DTO classes and entity classes are mixed in the controller and just DTO classes should be used for documentation. The lazydoc annotations support type parameters which specifies the used type instead of using reflection. So for example if a spring resolver resolves a client id to a Client entity you can specify with the type that the client should be a Long or String or so. If the type is not set lazydoc will check that the client type is not inherited from the configured baseDTOClassname and will report an error. If this parameter is not configured (default) everything is parsed.\r\n\r\n#### customAnnotationToBeIgnored\r\n\r\nIf there are already custom annotations used in the controllers which can be used to define methods or controllers to be ignored the class name of this annotation can be configured with this parameter.\r\n\r\n+++++ The following parameters will be updated in the near future +++++\r\n\r\n#### exceptionHandlerInvoker\r\n#### abstractControllerClassForCommonExceptionHandlers\r\n#### instanceControllerClassForCommonExceptionHandlers\r\n#### controllerClassToStopErrorInspection\r\n\r\n## PrinterConfig\r\n\r\n#### className\r\n\r\nThe classname of the printer which should be used.\r\n\r\n#### outputPath\r\n\r\nThe output path where the printer should generate the documentation artifacts.\r\n\r\n#### params\r\n\r\nThe params for the printer are provided as a map if needed.\r\n\r\n# Annotations\r\n\r\n## DomainDescription\r\n\r\n#### name\r\n\r\nThe name of the domain. \r\n\r\n#### shortDescription\r\n\r\nThe short description can be used in printers to describe in a short way what the domain is about. If the short description is not set the description will be used.\r\n\r\n#### description\r\n\r\nThe description of the domain provides a more detailed content what the domain is about.\r\n\r\n#### order\r\n\r\nThe order of the domain can be used to define the order of the different domains. If you have more than one domain you have to provide the order of the domains. So for example 1 Customer 2 Products etc.\r\n\t\r\n#### subDomain\r\n\r\nIf the domain is too big so that it is useful to divide it in subcategories you can define subdomains.\r\n\r\n#### externalDocumentation\r\n\r\nIf there are some additional informations to your domain which are not part of the documentation of your operations you can specify an external documentation which can be interpreted by the documentation printer and can be included   in the generated documentation artifacts.\r\n\r\n## SubDomainDescription\r\n\r\n#### name\r\n\r\nThe name of the sub domain. \r\n\r\n#### shortDescription\r\n\r\nThe short description can be used in printers to describe in a short way what the sub domain is about. If the short description is not set the description will be used.\r\n\r\n#### description\r\n\r\nThe description of the domain provides a more detailed content what the sub domain is about.\r\n\r\n#### order\r\n\r\nThe order of the sub domain can be used to define the order of the different sub domains. If you have more than one sub domain you have to provide the order of the sub domains. So for example domain Customer subdomains 1 master data management 2 registrations 3 contact address etc.\r\n\t\r\n#### externalDocumentation\r\n\r\nIf there are some additional informations to your sub domain which are not part of the documentation of your operations you can specify an external documentation which can be interpreted by the documentation printer and can be included in the generated documentation artifacts.\r\n\r\n## OperationDescription\r\n\r\n#### order\r\n\r\nThe order of the operations in your controller class. If not set the operations are sorted alphabetically\r\n\r\n#### description\r\n\r\nThe description what the operation is doing\r\n\r\n#### shortDescription\r\n\r\nThe short description what the operation is doing. If the short description is not set the description will be used.\r\n\r\n#### nickname\r\n\r\nThe nickname is the name of the method in the controller class. The nickname is for example used by swagger for expanding the details of an operation. If two operations have the same name because they are overloaded swagger can would expand both operation details. So with this parameter you can specify an alternative nick name\r\n\r\n#### notes\r\n\r\nA more detailed description of the operation.\r\n\r\n#### externalDocumentation\r\n\r\nIf there are some additional informations to your operation you can specify an external documentation which can be interpreted by the documentation printer and can be included in the generated documentation artifacts. For example tables which explain some things in a more detailed way. Things which can not be put easily in a common description.\r\n\r\n\r\n++++++ Will be updated soon ++++++++","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}